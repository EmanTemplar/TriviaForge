<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Trivia Player</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <!-- Navbar -->
  <nav class="navbar">
    <div class="logo">Trivia Player</div>
    <div id="navRoomInfo">
      <span id="navRoomCode">----</span>
      <span id="navConnectionStatus" title="Connection status">‚óè</span>
    </div>
    <div class="hamburger" id="hamburger">&#9776;</div>
    <ul class="menu" id="menu">
      <li><a href="display.html">Spectate</a></li>
      <li id="menuLeaveRoom">
        <a href="#" id="menuLeaveBtn">Leave Room</a>
      </li>
      <li id="menuPlayersSection">
        <div>Players in Room</div>
        <div id="menuPlayersList">
          <em>Not in a room yet</em>
        </div>
      </li>
      <li style="border-top: 1px solid rgba(255,255,255,0.1); padding-top: 0.5rem; margin-top: 0.5rem;">
        <a href="#" id="playerLogoutBtn" style="color: #f66;">Logout</a>
      </li>
    </ul>
  </nav>

  <!-- Main Content -->
  <div class="player-container">

    <!-- Left/Top: Question Display -->
    <div class="question-area">
      <div id="waitingScreen">
        <h2 id="waitingTitle">Join a Room to Start</h2>
        <p id="waitingMessage">Enter your name and room code to begin playing.</p>

        <!-- Recent Rooms Section -->
        <div id="recentRoomsSection" style="margin-top: 2rem; display: none;">
          <h3 style="font-size: 1.2rem; margin-bottom: 1rem; color: #4fc3f7;">Recent Rooms</h3>
          <div id="recentRoomsList" style="display: flex; flex-direction: column; gap: 0.75rem;">
            <!-- Recent rooms will be populated here -->
          </div>
        </div>
      </div>

      <div id="questionDisplay">
        <h2 id="questionText"></h2>

        <div id="choicesContainer">
          <!-- Choices will be populated here -->
        </div>

        <div id="answerFeedback">
          <!-- Feedback after answer revealed -->
        </div>
      </div>
    </div>

    <!-- Right/Bottom: Room/Lobby Status -->
    <div class="sidebar">

      <!-- Join Section -->
      <div id="joinSection">
        <h3>Join Room</h3>

        <label for="playerUsername">Username</label>
        <input id="playerUsername" type="text" placeholder="Choose a username" />
        <p style="font-size: 0.85rem; color: #aaa; margin: 0.25rem 0 0.75rem 0;">
          This will be your account name
        </p>

        <label for="playerDisplayName">Display Name</label>
        <input id="playerDisplayName" type="text" placeholder="Name shown in game" />
        <p style="font-size: 0.85rem; color: #aaa; margin: 0.25rem 0 0.75rem 0;">
          This is what other players will see
        </p>

        <label for="roomCodeManual">Room Code</label>
        <input id="roomCodeManual" type="text" placeholder="Enter room code" />

        <button id="joinBtn">Join Room</button>
        <button id="manageAccountBtn" style="margin-top: 0.5rem; background: rgba(0,123,255,0.2); border: 1px solid rgba(0,123,255,0.3);">
          Manage Account
        </button>
      </div>

      <!-- Room Info -->
      <div id="roomInfo">
        <h3>Room Info</h3>
        <div><strong>Room Code:</strong> <span id="displayRoomCode">----</span></div>
        <div><strong>Your Name:</strong> <span id="displayPlayerName">----</span></div>
        <button id="leaveBtn">Leave Room</button>
      </div>

      <!-- Players List -->
      <div class="players-list-container">
        <h3>Players in Room</h3>
        <div id="playersList">
          <em>Not in a room yet</em>
        </div>
      </div>

      <!-- Status Messages -->
      <div id="statusMessage">
        Ready to join
      </div>
    </div>
  </div>

  <!-- Custom Dialog Modal (for alerts and confirms) -->
  <div id="customDialog" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.85); display: none; align-items: center; justify-content: center; z-index: 2000;">
    <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); padding: 2rem; border-radius: 15px; max-width: 500px; width: 90%; box-shadow: 0 10px 40px rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.1);">
      <div style="margin-bottom: 1.5rem;">
        <h3 id="dialogTitle" style="margin: 0 0 1rem 0; color: #fff; font-size: 1.3rem; text-align: center;"></h3>
        <p id="dialogMessage" style="margin: 0; color: #aaa; font-size: 1rem; line-height: 1.5; text-align: center;"></p>
      </div>
      <div id="dialogButtons" style="display: flex; gap: 1rem; justify-content: center;"></div>
    </div>
  </div>

  <!-- Login Modal -->
  <div id="loginModal" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.85); display: none; align-items: center; justify-content: center; z-index: 2001;">
    <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); padding: 2rem; border-radius: 15px; max-width: 500px; width: 90%; box-shadow: 0 10px 40px rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.1);">
      <h3 style="margin: 0 0 1rem 0; color: #fff; font-size: 1.3rem; text-align: center;">Login Required</h3>
      <p style="margin: 0 0 1.5rem 0; color: #aaa; font-size: 0.95rem; text-align: center;">
        This username belongs to a registered account. Please enter your password to continue.
      </p>
      <form id="loginForm" style="display: flex; flex-direction: column; gap: 1rem;">
        <div>
          <label style="display: block; color: #aaa; font-size: 0.9rem; margin-bottom: 0.5rem;">Username</label>
          <input id="loginUsername" type="text" readonly style="width: 100%; padding: 0.75rem; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: #fff; font-size: 1rem;" />
        </div>
        <div>
          <label style="display: block; color: #aaa; font-size: 0.9rem; margin-bottom: 0.5rem;">Password</label>
          <input id="loginPassword" type="password" placeholder="Enter your password" required style="width: 100%; padding: 0.75rem; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: #fff; font-size: 1rem;" />
        </div>
        <div id="loginError" style="display: none; padding: 0.75rem; background: rgba(255,0,0,0.2); border: 1px solid rgba(255,0,0,0.4); border-radius: 8px; color: #ff6b6b; font-size: 0.9rem; text-align: center;"></div>
        <div style="display: flex; gap: 1rem; margin-top: 0.5rem;">
          <button type="submit" style="flex: 1; padding: 0.75rem; background: #4fc3f7; color: #fff; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; font-size: 1rem;">Login</button>
          <button type="button" id="loginCancel" style="flex: 1; padding: 0.75rem; background: rgba(255,255,255,0.1); color: #fff; border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; font-weight: bold; cursor: pointer; font-size: 1rem;">Cancel</button>
        </div>
      </form>
    </div>
  </div>

  <!-- Socket.IO -->
  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    const joinBtn = document.getElementById('joinBtn');
    const leaveBtn = document.getElementById('leaveBtn');
    const menuLeaveBtn = document.getElementById('menuLeaveBtn');
    const manageAccountBtn = document.getElementById('manageAccountBtn');
    const usernameInput = document.getElementById('playerUsername');
    const displayNameInput = document.getElementById('playerDisplayName');
    const roomInput = document.getElementById('roomCodeManual');

    const joinSection = document.getElementById('joinSection');
    const roomInfo = document.getElementById('roomInfo');
    const displayRoomCode = document.getElementById('displayRoomCode');
    const displayPlayerName = document.getElementById('displayPlayerName');
    const playersList = document.getElementById('playersList');
    const menuPlayersList = document.getElementById('menuPlayersList');
    const statusMessage = document.getElementById('statusMessage');
    const sidebar = document.querySelector('.sidebar');

    // Navbar elements (mobile)
    const navRoomInfo = document.getElementById('navRoomInfo');
    const navRoomCode = document.getElementById('navRoomCode');
    const navConnectionStatus = document.getElementById('navConnectionStatus');
    const menuLeaveRoom = document.getElementById('menuLeaveRoom');
    const menuPlayersSection = document.getElementById('menuPlayersSection');

    const waitingScreen = document.getElementById('waitingScreen');
    const questionDisplay = document.getElementById('questionDisplay');
    const questionText = document.getElementById('questionText');
    const choicesContainer = document.getElementById('choicesContainer');
    const answerFeedback = document.getElementById('answerFeedback');

    let currentRoomCode = null;
    let currentUsername = null; // Account username
    let currentDisplayName = null; // Display name shown in games
    let selectedAnswer = null;
    let answeredQuestions = new Set(); // Track which questions this player has answered
    let answerRevealTimeout = null; // Track the auto-hide timeout
    let lastActivityTime = Date.now(); // Track last activity for inactivity timeout
    let isConnected = false; // Track socket connection status

    // Pre-fill username and display name from localStorage if available
    const savedUsername = localStorage.getItem('playerUsername');
    const savedDisplayName = localStorage.getItem('playerDisplayName');
    const savedAccountType = localStorage.getItem('playerAccountType');
    if (savedUsername) {
      usernameInput.value = savedUsername;
    }
    if (savedDisplayName) {
      displayNameInput.value = savedDisplayName;
    }

    // --------------------
    // Recent Rooms Management
    // --------------------
    const MAX_RECENT_ROOMS = 5;
    const RECENT_ROOMS_KEY = 'playerRecentRooms';

    function getRecentRooms() {
      const stored = localStorage.getItem(RECENT_ROOMS_KEY);
      return stored ? JSON.parse(stored) : [];
    }

    function saveRecentRoom(roomCode) {
      let recentRooms = getRecentRooms();

      // Remove if already exists (to update timestamp)
      recentRooms = recentRooms.filter(room => room.code !== roomCode);

      // Add to front with current timestamp
      recentRooms.unshift({
        code: roomCode,
        timestamp: Date.now(),
        username: currentUsername,
        displayName: currentDisplayName
      });

      // Keep only the most recent rooms
      recentRooms = recentRooms.slice(0, MAX_RECENT_ROOMS);

      localStorage.setItem(RECENT_ROOMS_KEY, JSON.stringify(recentRooms));
      // Note: We don't call displayRecentRooms() here to avoid race conditions
      // Recent rooms are displayed explicitly on page load and when leaving a room
    }

    async function displayRecentRooms() {
      let recentRooms = getRecentRooms();
      const recentRoomsSection = document.getElementById('recentRoomsSection');
      const recentRoomsList = document.getElementById('recentRoomsList');

      if (recentRooms.length === 0) {
        recentRoomsSection.style.display = 'none';
        return;
      }

      // Check which rooms are still active
      try {
        const roomCodes = recentRooms.map(room => room.code);
        const response = await fetch('/api/rooms/check-active', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ roomCodes })
        });

        if (response.ok) {
          const data = await response.json();
          const activeRoomCodes = data.activeRooms;

          // Filter to only show active rooms
          recentRooms = recentRooms.filter(room => activeRoomCodes.includes(room.code));

          // Update localStorage to remove inactive rooms
          if (recentRooms.length !== getRecentRooms().length) {
            localStorage.setItem(RECENT_ROOMS_KEY, JSON.stringify(recentRooms));
          }

          // If no active rooms remain, hide the section
          if (recentRooms.length === 0) {
            recentRoomsSection.style.display = 'none';
            return;
          }
        }
      } catch (err) {
        console.error('Error checking active rooms:', err);
        // On error, show all rooms (fallback to current behavior)
      }

      recentRoomsSection.style.display = 'block';

      recentRoomsList.innerHTML = recentRooms.map(room => {
        const timeAgo = getTimeAgo(room.timestamp);
        return `
          <button onclick="quickJoinRoom('${room.code}')" style="
            padding: 1rem;
            background: rgba(79, 195, 247, 0.1);
            border: 1px solid rgba(79, 195, 247, 0.3);
            border-radius: 8px;
            color: #fff;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s;
          " onmouseover="this.style.background='rgba(79, 195, 247, 0.2)'" onmouseout="this.style.background='rgba(79, 195, 247, 0.1)'">
            <div style="text-align: left;">
              <div style="font-size: 1.1rem; font-weight: bold; color: #4fc3f7;">Room ${room.code}</div>
              <div style="font-size: 0.85rem; color: #aaa; margin-top: 0.25rem;">Joined ${timeAgo}</div>
            </div>
            <div style="font-size: 0.9rem; color: #4fc3f7;">‚Üí Quick Join</div>
          </button>
        `;
      }).join('');
    }

    function getTimeAgo(timestamp) {
      const seconds = Math.floor((Date.now() - timestamp) / 1000);
      if (seconds < 60) return 'just now';
      const minutes = Math.floor(seconds / 60);
      if (minutes < 60) return `${minutes} min ago`;
      const hours = Math.floor(minutes / 60);
      if (hours < 24) return `${hours} hour${hours > 1 ? 's' : ''} ago`;
      const days = Math.floor(hours / 24);
      return `${days} day${days > 1 ? 's' : ''} ago`;
    }

    window.quickJoinRoom = async (roomCode) => {
      if (!savedUsername || !savedDisplayName) {
        await customAlert('Please enter your username and display name first.', 'Missing Information');
        return;
      }

      currentUsername = savedUsername;
      currentDisplayName = savedDisplayName;
      currentRoomCode = roomCode;
      roomInput.value = roomCode;

      socket.emit('joinRoom', { roomCode, username: savedUsername, displayName: savedDisplayName });
    };

    // Display recent rooms on page load
    displayRecentRooms();

    // --------------------
    // Registered Player Auto-Login
    // --------------------
    async function autoLoginRegisteredPlayer() {
      const playerToken = localStorage.getItem('playerAuthToken');

      if (playerToken && savedAccountType === 'registered') {
        try {
          // Verify token is still valid
          const response = await fetch('/api/auth/verify-player', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${playerToken}`
            }
          });

          if (response.ok) {
            const data = await response.json();
            // Show welcome message
            const waitingMessage = document.getElementById('waitingMessage');
            waitingMessage.innerHTML = `Welcome back, <strong style="color: #4fc3f7;">${data.user.username}</strong>! üëã<br><span style="font-size: 0.9rem;">Your account is ready. Enter a room code to join.</span>`;
          } else {
            // Token expired or invalid, remove it
            localStorage.removeItem('playerAuthToken');
          }
        } catch (err) {
          console.error('Auto-login error:', err);
          localStorage.removeItem('playerAuthToken');
        }
      }
    }

    // Run auto-login check
    autoLoginRegisteredPlayer();

    // --------------------
    // Custom Dialog Functions
    // --------------------
    const customAlert = (message, title = 'Notification') => {
      return new Promise((resolve) => {
        const dialog = document.getElementById('customDialog');
        const dialogTitle = document.getElementById('dialogTitle');
        const dialogMessage = document.getElementById('dialogMessage');
        const dialogButtons = document.getElementById('dialogButtons');

        dialogTitle.textContent = title;
        dialogMessage.textContent = message;

        dialogButtons.innerHTML = '';
        const okBtn = document.createElement('button');
        okBtn.textContent = 'OK';
        okBtn.style.cssText = 'padding: 0.75rem 2rem; background: rgba(0,123,255,0.3); border: 1px solid rgba(0,123,255,0.5); color: #fff; border-radius: 8px; cursor: pointer; font-size: 1rem; font-weight: bold; transition: all 0.2s;';
        okBtn.onmouseover = () => okBtn.style.background = 'rgba(0,123,255,0.5)';
        okBtn.onmouseout = () => okBtn.style.background = 'rgba(0,123,255,0.3)';
        okBtn.onclick = () => {
          dialog.style.display = 'none';
          resolve();
        };
        dialogButtons.appendChild(okBtn);

        dialog.style.display = 'flex';
        okBtn.focus();
      });
    };

    const customConfirm = (message, title = 'Confirm Action') => {
      return new Promise((resolve) => {
        const dialog = document.getElementById('customDialog');
        const dialogTitle = document.getElementById('dialogTitle');
        const dialogMessage = document.getElementById('dialogMessage');
        const dialogButtons = document.getElementById('dialogButtons');

        dialogTitle.textContent = title;
        dialogMessage.textContent = message;

        dialogButtons.innerHTML = '';

        const cancelBtn = document.createElement('button');
        cancelBtn.textContent = 'Cancel';
        cancelBtn.style.cssText = 'padding: 0.75rem 2rem; background: rgba(100,100,100,0.3); border: 1px solid rgba(100,100,100,0.5); color: #fff; border-radius: 8px; cursor: pointer; font-size: 1rem; transition: all 0.2s;';
        cancelBtn.onmouseover = () => cancelBtn.style.background = 'rgba(100,100,100,0.5)';
        cancelBtn.onmouseout = () => cancelBtn.style.background = 'rgba(100,100,100,0.3)';
        cancelBtn.onclick = () => {
          dialog.style.display = 'none';
          resolve(false);
        };

        const confirmBtn = document.createElement('button');
        confirmBtn.textContent = 'Confirm';
        confirmBtn.style.cssText = 'padding: 0.75rem 2rem; background: rgba(0,200,0,0.3); border: 1px solid rgba(0,200,0,0.5); color: #fff; border-radius: 8px; cursor: pointer; font-size: 1rem; font-weight: bold; transition: all 0.2s;';
        confirmBtn.onmouseover = () => confirmBtn.style.background = 'rgba(0,200,0,0.5)';
        confirmBtn.onmouseout = () => confirmBtn.style.background = 'rgba(0,200,0,0.3)';
        confirmBtn.onclick = () => {
          dialog.style.display = 'none';
          resolve(true);
        };

        dialogButtons.appendChild(cancelBtn);
        dialogButtons.appendChild(confirmBtn);

        dialog.style.display = 'flex';
        confirmBtn.focus();
      });
    };

    // Get answer display timeout from Options (default 30 seconds)
    function getAnswerDisplayTimeout() {
      try {
        const saved = localStorage.getItem('quizOptions');
        if (saved) {
          const options = JSON.parse(saved);
          return (options.answerDisplayTime || 30) * 1000; // Convert to milliseconds
        }
      } catch (e) {
        console.error('Error reading quiz options:', e);
      }
      return 30000; // Default 30 seconds
    }

    // ---------------------------
    // Connection Status Management
    // ---------------------------
    function updateConnectionStatus(connected) {
      isConnected = connected;
      if (connected) {
        navConnectionStatus.style.color = '#0f0'; // Green
        navConnectionStatus.title = 'Connected';
      } else {
        navConnectionStatus.style.color = '#f00'; // Red
        navConnectionStatus.title = 'Disconnected';
      }
    }

    // Socket connection events
    socket.on('connect', () => {
      updateConnectionStatus(true);
      console.log('Connected to server');
    });

    socket.on('disconnect', () => {
      updateConnectionStatus(false);
      console.log('Disconnected from server');
    });

    // ---------------------------
    // Helper: Reset to waiting screen
    // ---------------------------
    function resetToWaiting() {
      waitingScreen.style.display = 'flex';
      questionDisplay.style.display = 'none';
      selectedAnswer = null;
    }

    // ---------------------------
    // Helper: Update player list (sync sidebar + menu)
    // ---------------------------
    function updatePlayerList(players) {
      const html = players.map((p, idx) =>
        `<div class="player-item"><strong>${idx + 1}.</strong> <span style="color: ${p.connected ? '#0f0' : '#f00'}">‚óè</span> ${p.name}${p.choice !== null ? ' ‚úì' : ''}</div>`
      ).join('');

      // Update sidebar (desktop)
      playersList.innerHTML = html || '<em>No players yet</em>';

      // Update menu (mobile)
      menuPlayersList.innerHTML = html || '<em>Not in a room yet</em>';
    }

    // ---------------------------
    // Helper: Detect mobile device
    // ---------------------------
    function isMobile() {
      return window.innerWidth <= 768;
    }

    // Adjust grid for mobile vs desktop
    function adjustChoiceGrid() {
      if (isMobile()) {
        choicesContainer.style.gridTemplateColumns = '1fr';
      } else {
        choicesContainer.style.gridTemplateColumns = '1fr 1fr';
      }
    }

    window.addEventListener('resize', adjustChoiceGrid);

    // ---------------------------
    // Navigation (hamburger)
    // ---------------------------
    const menu = document.getElementById('menu');
    const hamburger = document.getElementById('hamburger');

    // Toggle menu on click (works on both mobile and desktop)
    hamburger.addEventListener('click', (e) => {
      e.stopPropagation(); // Prevent document listener from immediately closing
      menu.classList.toggle('open');
    });

    // Close menu when clicking/touching outside
    const closeMenuIfOutside = (e) => {
      if (menu.classList.contains('open') && !menu.contains(e.target) && e.target !== hamburger) {
        menu.classList.remove('open');
      }
    };

    document.addEventListener('click', closeMenuIfOutside);
    document.addEventListener('touchstart', closeMenuIfOutside);

    // Menu leave button (mobile)
    menuLeaveBtn.addEventListener('click', async (e) => {
      e.preventDefault();
      menu.classList.remove('open'); // Close menu first
      const confirmed = await customConfirm('Leave this room?', 'Leave Room');
      if (confirmed) {
        handleLeaveRoom();
      }
    });

    // ---------------------------
    // Logout functionality
    // ---------------------------
    const playerLogoutBtn = document.getElementById('playerLogoutBtn');
    if (playerLogoutBtn) {
      playerLogoutBtn.addEventListener('click', async (e) => {
        e.preventDefault();
        menu.classList.remove('open'); // Close menu first

        const confirmed = await customConfirm(
          'Are you sure you want to logout?\n\nThis will:\n- Clear your saved username and display name\n- Clear your recent rooms list\n- Log you out of your account (if registered)',
          'Logout'
        );

        if (!confirmed) return;

        // Leave room if currently in one
        if (currentRoomCode) {
          handleLeaveRoom();
        }

        // Clear all player data from localStorage
        localStorage.removeItem('playerUsername');
        localStorage.removeItem('playerDisplayName');
        localStorage.removeItem('playerAccountType');
        localStorage.removeItem('playerAuthToken');
        localStorage.removeItem('playerRecentRooms');

        // Clear form inputs
        usernameInput.value = '';
        displayNameInput.value = '';
        roomInput.value = '';

        // Reset welcome message
        const waitingMessage = document.getElementById('waitingMessage');
        waitingMessage.textContent = 'Enter your name and room code to begin playing.';

        await customAlert('You have been logged out successfully.', 'Logged Out');
      });
    }

    // ---------------------------
    // Username Authentication Check
    // ---------------------------
    async function checkUsernameAuth(username) {
      try {
        const response = await fetch('/api/auth/check-username', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ username })
        });

        if (!response.ok) {
          throw new Error('Failed to check username');
        }

        return await response.json();
      } catch (err) {
        console.error('Username check error:', err);
        throw err;
      }
    }

    // Show login modal
    function showLoginModal(username) {
      return new Promise((resolve, reject) => {
        const loginModal = document.getElementById('loginModal');
        const loginUsername = document.getElementById('loginUsername');
        const loginPassword = document.getElementById('loginPassword');
        const loginError = document.getElementById('loginError');
        const loginForm = document.getElementById('loginForm');
        const loginCancel = document.getElementById('loginCancel');

        loginUsername.value = username;
        loginPassword.value = '';
        loginError.style.display = 'none';

        loginModal.style.display = 'flex';
        loginPassword.focus();

        // Handle form submission
        const handleSubmit = async (e) => {
          e.preventDefault();
          const password = loginPassword.value;

          try {
            const response = await fetch('/api/auth/player-login', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ username, password })
            });

            const data = await response.json();

            if (response.ok) {
              // Login successful
              localStorage.setItem('playerAuthToken', data.token);
              localStorage.setItem('playerUsername', username);
              localStorage.setItem('playerAccountType', 'registered');

              loginModal.style.display = 'none';
              loginForm.removeEventListener('submit', handleSubmit);
              loginCancel.removeEventListener('click', handleCancel);
              resolve(true);
            } else {
              // Login failed
              loginError.textContent = data.error || 'Invalid password';
              loginError.style.display = 'block';
              loginPassword.value = '';
              loginPassword.focus();
            }
          } catch (err) {
            console.error('Login error:', err);
            loginError.textContent = 'Login failed. Please try again.';
            loginError.style.display = 'block';
          }
        };

        // Handle cancel
        const handleCancel = () => {
          loginModal.style.display = 'none';
          loginForm.removeEventListener('submit', handleSubmit);
          loginCancel.removeEventListener('click', handleCancel);
          reject(new Error('Login cancelled'));
        };

        loginForm.addEventListener('submit', handleSubmit);
        loginCancel.addEventListener('click', handleCancel);
      });
    }

    // ---------------------------
    // Join room logic
    // ---------------------------
    joinBtn.addEventListener('click', async () => {
      const username = usernameInput.value.trim();
      const displayName = displayNameInput.value.trim();
      const roomCode = roomInput.value.trim();

      if (!username) {
        await customAlert('Please enter a username.', 'Missing Information');
        return;
      }

      if (!displayName) {
        await customAlert('Please enter a display name.', 'Missing Information');
        return;
      }

      if (!roomCode) {
        await customAlert('Please enter a room code.', 'Missing Information');
        return;
      }

      try {
        // Check if username requires authentication
        const authCheck = await checkUsernameAuth(username);

        if (authCheck.requiresAuth) {
          // This username belongs to a registered account - require login
          try {
            await showLoginModal(username);
            // Login successful - proceed with join
          } catch (err) {
            // Login cancelled or failed
            return;
          }
        } else {
          // Guest account or new username - no auth required
          localStorage.setItem('playerUsername', username);
          localStorage.setItem('playerDisplayName', displayName);
          localStorage.setItem('playerAccountType', 'Guest');
        }

        // Save display name
        localStorage.setItem('playerDisplayName', displayName);

        currentUsername = username;
        currentDisplayName = displayName;
        currentRoomCode = roomCode;

        socket.emit('joinRoom', { roomCode, username, displayName });
      } catch (err) {
        console.error('Join error:', err);
        await customAlert('Failed to join room. Please try again.', 'Error');
      }
    });

    // Manage Account button
    manageAccountBtn.addEventListener('click', async () => {
      const username = usernameInput.value.trim();

      if (!username) {
        await customAlert('Please enter a username first.', 'Missing Information');
        return;
      }

      try {
        // Check if username requires authentication
        const authCheck = await checkUsernameAuth(username);

        if (authCheck.requiresAuth) {
          // This username belongs to a registered account - require login
          try {
            await showLoginModal(username);
            // Login successful - proceed to manage account
          } catch (err) {
            // Login cancelled or failed
            return;
          }
        } else {
          // Guest account or new username - allow access
          localStorage.setItem('playerUsername', username);
          localStorage.setItem('playerAccountType', authCheck.exists ? 'Guest' : 'Guest');

          // If display name is filled, save it too
          const displayName = displayNameInput.value.trim();
          if (displayName) {
            localStorage.setItem('playerDisplayName', displayName);
          }
        }

        window.location.href = 'player-manage.html';
      } catch (err) {
        console.error('Manage account error:', err);
        await customAlert('Failed to access account management. Please try again.', 'Error');
      }
    });

    // Room joined successfully
    socket.on('playerListUpdate', ({ roomCode, players }) => {
      if (roomCode !== currentRoomCode) return;

      // Update room info display (desktop)
      joinSection.style.display = 'none';
      roomInfo.style.display = 'block';
      displayRoomCode.textContent = roomCode;
      displayPlayerName.textContent = currentDisplayName;

      // Update navbar (mobile)
      navRoomInfo.classList.add('active');
      navRoomCode.textContent = roomCode;

      // Show menu items (mobile)
      menuLeaveRoom.style.display = 'block';
      menuPlayersSection.style.display = 'block';

      // Hide sidebar on mobile after joining
      sidebar.classList.add('in-room');

      // Update waiting screen text now that player is in a room
      const waitingTitle = document.getElementById('waitingTitle');
      const waitingMessage = document.getElementById('waitingMessage');
      if (waitingTitle) waitingTitle.textContent = 'Waiting for Question...';
      if (waitingMessage) waitingMessage.textContent = 'The presenter will send questions when ready.';

      // Update players list (both sidebar and menu)
      updatePlayerList(players);

      statusMessage.textContent = `${players.length} player(s) in room`;

      // Save to recent rooms
      saveRecentRoom(roomCode);

      // Hide recent rooms section while in a room
      document.getElementById('recentRoomsSection').style.display = 'none';
    });

    // ---------------------------
    // Answer history restored (for reconnecting players)
    // ---------------------------
    socket.on('answerHistoryRestored', ({ answeredQuestions: answeredIndices }) => {
      // Populate the answeredQuestions Set with the indices the player has already answered
      answeredQuestions.clear();
      answeredIndices.forEach(idx => answeredQuestions.add(idx));
      console.log(`[RESUME DEBUG] Answer history restored:`, answeredIndices, 'Set now contains:', Array.from(answeredQuestions));
    });

    // ---------------------------
    // Answer rejected (tried to re-answer)
    // ---------------------------
    socket.on('answerRejected', ({ message, questionIndex }) => {
      console.log(`[ANSWER LOCK] Answer rejected for question ${questionIndex}: ${message}`);
      statusMessage.textContent = message;
      statusMessage.style.background = 'rgba(255,0,0,0.3)';
      statusMessage.style.color = '#f00';

      // Add the question to the answered set if it's not already there
      answeredQuestions.add(questionIndex);

      // Disable all choice buttons to prevent further attempts
      document.querySelectorAll('.choice-btn').forEach(btn => {
        btn.disabled = true;
      });
    });

    // ---------------------------
    // Leave room logic
    // ---------------------------
    function handleLeaveRoom() {
      socket.disconnect();
      socket.connect();
      currentRoomCode = null;
      currentUsername = null;
      currentDisplayName = null;
      selectedAnswer = null;
      answeredQuestions.clear();

      // Hide room info (desktop)
      joinSection.style.display = 'block';
      roomInfo.style.display = 'none';

      // Hide navbar room info (mobile)
      navRoomInfo.classList.remove('active');
      navRoomCode.textContent = '----';

      // Hide menu items (mobile)
      menuLeaveRoom.style.display = 'none';
      menuPlayersSection.style.display = 'none';

      // Show sidebar again on mobile (for join form)
      sidebar.classList.remove('in-room');

      // Reset waiting screen text
      const waitingTitle = document.getElementById('waitingTitle');
      const waitingMessage = document.getElementById('waitingMessage');
      if (waitingTitle) waitingTitle.textContent = 'Join a Room to Start';
      if (waitingMessage) waitingMessage.textContent = 'Enter your name and room code to begin playing.';

      resetToWaiting();
      updatePlayerList([]);
      statusMessage.textContent = 'Ready to join';

      // Show recent rooms section again
      displayRecentRooms();
    }

    // Desktop leave button
    leaveBtn.addEventListener('click', async () => {
      const confirmed = await customConfirm('Leave this room?', 'Leave Room');
      if (confirmed) {
        handleLeaveRoom();
      }
    });

    // ---------------------------
    // Question presented by presenter
    // ---------------------------
    socket.on('questionPresented', ({ questionIndex, question }) => {
      // Clear any existing answer reveal timeout
      if (answerRevealTimeout) {
        clearTimeout(answerRevealTimeout);
        answerRevealTimeout = null;
      }

      waitingScreen.style.display = 'none';
      questionDisplay.style.display = 'flex';
      answerFeedback.style.display = 'none';

      questionText.textContent = question.text;
      selectedAnswer = null;
      adjustChoiceGrid();

      // Check if this question was already answered
      const alreadyAnswered = answeredQuestions.has(questionIndex);
      console.log(`[RESUME DEBUG] Question ${questionIndex} presented. Already answered?`, alreadyAnswered, 'Set contains:', Array.from(answeredQuestions));

      // Render choices
      choicesContainer.innerHTML = question.choices.map((choice, idx) => {
        const isDisabled = alreadyAnswered ? 'disabled' : '';
        const choiceLetter = String.fromCharCode(65 + idx); // A, B, C, D, etc.

        return `
          <button
            class="choice-btn"
            data-index="${idx}"
            ${isDisabled}
          >
            <strong>${choiceLetter}.</strong> ${choice}
          </button>
        `;
      }).join('');

      if (alreadyAnswered) {
        statusMessage.textContent = 'You already answered this question';
        statusMessage.style.background = 'rgba(255,165,0,0.3)';
      } else {
        statusMessage.textContent = 'Select your answer';
        statusMessage.style.background = 'rgba(0,123,255,0.2)';
      }

      // Add click handlers to choices (only if not already answered)
      if (!alreadyAnswered) {
        document.querySelectorAll('.choice-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            if (answeredQuestions.has(questionIndex)) return; // Double-check

            // Remove previous selection
            document.querySelectorAll('.choice-btn').forEach(b => {
              b.classList.remove('selected');
            });

            // Mark this choice as selected
            btn.classList.add('selected');

            selectedAnswer = parseInt(btn.dataset.index);
            answeredQuestions.add(questionIndex); // Lock this question

            // Disable all buttons after selection
            document.querySelectorAll('.choice-btn').forEach(b => {
              b.disabled = true;
            });

            // Submit answer
            socket.emit('submitAnswer', { roomCode: currentRoomCode, choice: selectedAnswer });

            statusMessage.textContent = 'Answer submitted! ‚úì';
            statusMessage.style.background = 'rgba(0,200,0,0.3)';
          });
        });
      }
    });

    // ---------------------------
    // Answer revealed by presenter
    // ---------------------------
    socket.on('questionRevealed', ({ questionIndex, question, results }) => {
      const myResult = results.find(r => r.name === currentDisplayName);
      const correctChoice = question.correctChoice;

      // Show feedback
      answerFeedback.style.display = 'block';
      
      if (myResult && myResult.is_correct) {
        answerFeedback.style.background = 'rgba(0,200,0,0.3)';
        answerFeedback.style.color = '#0f0';
        answerFeedback.innerHTML = `‚úì Correct! The answer was: <strong>${question.choices[correctChoice]}</strong>`;
      } else {
        answerFeedback.style.background = 'rgba(200,0,0,0.3)';
        answerFeedback.style.color = '#f66';
        answerFeedback.innerHTML = `‚úó Incorrect. The correct answer was: <strong>${question.choices[correctChoice]}</strong>`;
      }

      // Highlight correct answer in choices
      document.querySelectorAll('.choice-btn').forEach((btn, idx) => {
        if (idx === correctChoice) {
          btn.classList.add('correct');
        } else if (idx === selectedAnswer && selectedAnswer !== correctChoice) {
          btn.classList.add('incorrect');
        }
      });

      statusMessage.textContent = myResult && myResult.is_correct ? 'You got it right! üéâ' : 'Better luck next time!';
      statusMessage.style.background = myResult && myResult.is_correct ? 'rgba(0,200,0,0.3)' : 'rgba(200,0,0,0.3)';

      // Clear any existing timeout
      if (answerRevealTimeout) {
        clearTimeout(answerRevealTimeout);
      }

      // Reset to waiting screen after configured timeout
      const timeout = getAnswerDisplayTimeout();
      answerRevealTimeout = setTimeout(() => {
        resetToWaiting();
        statusMessage.textContent = 'Waiting for next question...';
        statusMessage.style.background = 'rgba(255,255,255,0.1)';
        answerRevealTimeout = null;
      }, timeout);
    });

    // ---------------------------
    // Error handling
    // ---------------------------
    socket.on('roomError', msg => {
      customAlert(msg, 'Room Error');
      statusMessage.textContent = 'Error: ' + msg;
      statusMessage.style.background = 'rgba(255,0,0,0.3)';
    });

    socket.on('roomClosed', () => {
      customAlert('Room closed by presenter.', 'Room Closed');
      handleLeaveRoom();
      statusMessage.textContent = 'Room was closed';
      statusMessage.style.background = 'rgba(255,0,0,0.3)';
    });

    // Initialize
    adjustChoiceGrid();
    updateConnectionStatus(socket.connected);

    // Auto-fill room code from URL parameter
    const urlParams = new URLSearchParams(window.location.search);
    const roomCodeParam = urlParams.get('room');
    if (roomCodeParam) {
      roomInput.value = roomCodeParam;
      nameInput.focus(); // Focus on name input if room is pre-filled
    }
  </script>
</body>
</html>